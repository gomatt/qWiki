<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="description" content="qWiki">
<script src=http://code.jquery.com/jquery-2.1.3.min.js></script>
<script src=pages.js></script>
<script>
//<![CDATA[
(function(qWiki) {
	qWiki(window.jQuery, window, document);
} (function($, window, document) {
	$(function() {
		get_Book();
		$(document).ready(function() {
			// DOM ready
			set_Page(fix_QueryString(get_QueryString()["p"]));
			
			// user clicks a link
			$(document).delegate('a', 'click', function() {
				var target = $(this).attr("title");
				set_Page(target);
			});
		});
	});

	// configuration
	var config = {
		'version':'0.1a',
		'home':'main page', // default page
		'page_divider':':',
		'action_divider':'::',
		'core_title':'core',
		'style_title':'style',
		'template_title':'template'
	};
	
	// script start
	console.log('Script started: qWiki ' + config.version);
	
	// 'global' variables
	var page_titles = [],
	//page_content = [],
	xml = "",
	$xml = {};

	// remove
	var bookshelf = {
		xml: function() {
			return $.parseXML(book)
		}
	};

	// parse xml document, if available
	function get_Book() {
		if (typeof book !== 'undefined') {
			xml = $.parseXML(book);
			$xml = $(xml);
			
			$xml.find('page').each(function() {
				page_titles.push($(this).attr('title'));
				//page_content.push($(this).find('content').text());
			});
			console.log("Book available; pages found: " + page_titles.length);
		} else {
			console.log("Book not found!");
		}
	}

	// page object
	var page = {
		title: config.home,
		exist: function() {
			return $xml.find('page[title="' + this.title + '"]').length;
		},
		changed: false,
		type: function() {
			return $xml.find('page[title="' + this.title + '"]').find('type').text() || 'page';
		},
		tags: function () {
			
		},
		content: function(type) {
			switch (type) {
				case 'page':
					return content = parse($xml.find('page[title="' + this.title + '"]').find('content').text());
				case 'nowiki':
					return $xml.find('page[title="' + this.title + '"]').find('content').text();
				default:
					return $xml.find('page[title="' + this.title + '"]').find('content').text();
			}
		},
		html: function() {
			var html = "";
			// add template html
			html += this.modifier(config.template_title, false);
			
			// insert simple values into template
			//html = html.replace(/%(\w*)%/g,function(m,key){return template_values.hasOwnProperty(key)?template_values[key]:m;});
			
			// replace template values with content
			html = html.replace(/{{=page_title}}/g, this.title) // page title
			.replace(/{{=page_content}}/g, this.content(this.type())) // page content after being parsed
			.replace(/{{=page_content_raw}}/g, this.content()); // raw content
			
			// return content
			return html;
		},
		namespaces: function() {
			var namespaces = this.title;
			var re_action = new RegExp(config.action_divider + '(.+)?','g');
			
			// remove actions, if any
			namespaces = namespaces.replace(re_action, "");
			
			// split namespaces
			namespaces = namespaces.split(config.page_divider);
			
			// remove pagename
			namespaces.pop();
			
			return namespaces;
		},
		modifier: function(modifier_type, all) {
			if (typeof modifier_type == 'undefined')
				return false;
				
			var new_modifier = "",
			namespace_titles = "",
			modifier = "",
			namespaces = this.namespaces();
			
			// load core modifier once
			if (namespaces[0] == config.core_title) namespaces.shift();
			modifier = page_Content(config.core_title + config.page_divider + modifier_type);
			
			// load default modifier
			modifier += page_Content(config.page_divider + modifier_type);
			
			// load each namespace modifier, if available
			$.each(namespaces, function(i, namespace_title) {
				namespace_titles += namespace_title + config.page_divider;
				new_modifier = page_Content(namespace_titles + modifier_type);
				if (new_modifier) {
					if (all)
						modifier += "\n" + new_modifier;
					else
						modifier = new_modifier;
				}
			});
			return modifier;
		}
	};

	// regex
	var re = {
		html_remove: /<\/?([^<\/\s>]+)[^<>\n]*>/g,
		link_internal: /\[\[([^\]\|]*)(?:\|([^\]]*))?\]\]/g,
		italic: /(?!\/|\s\/{2})(^|[\s\-_'"*>;([{<])\/(.+?)\//mg,
		emphasis: /(^|[\s\-_'"*>;([{<])\/{2}(.+?)\/{2}/mg,
		underline: /(^|[\s\/\-'"*>;([{<])_(.+?)_/mg,
		strike_through: /(?!^\-{2}|\s\-{2})(^|[\s\/_'"*>;([{<])\-(.+?)\-/mg,
		del: /(^|[\s\/'"*>;([{<])\-{2}(.+?)\-{2}/mg,
		strong: /(^|[\s\/\-'"*>;([{<])\!(.+?)\!/mg,
		bold: /(^|[\s\/\-'">;([{<])\*(.+?)\*/mg,
		new_line: /\n/g
	}

	// content parser
	function parse(content) {
		content = content//.replace(/\\\n/g, "")
			.replace(re.html_remove, "")
			.replace(re.italic, "$1<"+"i>$2<"+"/i>")
			.replace(re.emphasis, "$1<"+"em>$2<"+"/em>")
			.replace(re.underline, "$1<"+"span style=\"text-decoration:underline;\">$2<"+"/span>")
			.replace(re.strike_through, "$1<"+"s>$2<"+"/s>")
			.replace(re.del, "$1<"+"del>$2<"+"/del>")
			.replace(re.bold, "$1<"+"b>$2<"+"/b>")
			.replace(re.strong, "$1<"+"strong>$2<"+"/strong>")
			.replace(re.new_line, "<"+"br>")
			.replace(re.link_internal, function(str, target, label) {
				// [[link|label]] or [[link]]
				if (target)
					return render_WikiLink(target, label);
				return str; // invalid
			});
		return content;
	}

	// RENDERING FUNCTIONS
	function render_WikiLink(target, label) {
		label = label || target;
		// create link
		var $link = $('<a>', {
			title: target,
			text: label
		});
		
		// add link classes, if required
		if (!page_Content(target)) $link.addClass('broken');
		
		return $link.get(0).outerHTML;
	}

	// MISC FUNCTIONS
	// return raw content of specific page
	function page_Content(page_Title) {
		return $xml.find('page[title="' + page_Title + '"]').find('content').text();
	}
	// append namespace styling to head
	function load_Style() {
		// clear styles
		$('style').remove();
		
		// load page styles
		var style = $('<style>', {
			html: page.modifier(config.style_title, true)
		});
		return style.appendTo('head');
	}
	// append content to body
	function load_Content() {
		$('body').html(page.html());
	}

	// Read a page's GET URL variables and return them as an associative array.
	function get_QueryString()
	{
			var vars = [], hash;
			var hashes = window.location.href.slice(window.location.href.indexOf('?') + 1).split('&');
			for(var i = 0; i < hashes.length; i++)
			{
					hash = hashes[i].split('=');
					vars.push(hash[0]);
					vars[hash[0]] = hash[1];
			}
			return vars;
	}
	
	function fix_QueryString(str) {
		if (typeof str === 'undefined')
			return false;

		var re_action = new RegExp(config.action_divider + '(.+)?','g');
		str = decodeURI(str);
		
		str = str
			.trim()
			.toLowerCase()
			.replace(re_action, "")
			.replace(/\+/g, " ");

		return str;
	}

	// MAIN FUNCTIONS
	// set current page
	function set_Page(page_Title) {
		page.title = page_Title || config.home;

		if (page.exist()) {
			var execStart = new Date().getTime();
			console.log('Set page: "' + page.title + '"');
			load_Style();
			load_Content();
			document.title = page.title;
			var execTime = new Date().getTime() - execStart;
			console.log("Execution time: " + execTime + " ms");
		} else {
			console.log('Page not found!');
			set_Page(config.home);
		}
	}
}));
//]]>
</script>
</head>
<body>
</body>
</html>